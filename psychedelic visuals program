import cv2
import numpy as np
import random
import time
import pyautogui

# Get screen resolution dynamically
screen_width, screen_height = pyautogui.size()

# Timer for rare face appearances
last_face_time = 0
FACE_COOLDOWN = 180  # At most once every 3 minutes (180 seconds)

def random_color():
    return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))

def draw_random_shape(canvas):
    shape_type = random.choice(["circle", "rectangle", "polygon", "lines", "gradient", "wave"])
    
    if shape_type == "circle":
        center = (random.randint(0, screen_width), random.randint(0, screen_height))
        radius = random.randint(10, 200)
        color = random_color()
        thickness = random.choice([-1, 2, 4])  # -1 means filled
        cv2.circle(canvas, center, radius, color, thickness)
    
    elif shape_type == "rectangle":
        pt1 = (random.randint(0, screen_width), random.randint(0, screen_height))
        pt2 = (random.randint(0, screen_width), random.randint(0, screen_height))
        color = random_color()
        thickness = random.choice([-1, 2, 4])
        cv2.rectangle(canvas, pt1, pt2, color, thickness)
    
    elif shape_type == "polygon":
        num_points = random.randint(3, 10)  # At least 3 points
        points = np.array([
            [random.randint(0, screen_width), random.randint(0, screen_height)] for _ in range(num_points)
        ], np.int32)

        # Fix: Ensure points array is correctly shaped and not empty
        if points.shape[0] >= 3:  # Ensure at least a triangle
            points = points.reshape((-1, 1, 2))
            color = random_color()
            thickness = random.choice([-1, 2])
            cv2.polylines(canvas, [points], isClosed=True, color=color, thickness=thickness)
            if thickness == -1:
                cv2.fillPoly(canvas, [points], color)
    
    elif shape_type == "lines":
        for _ in range(random.randint(5, 20)):
            pt1 = (random.randint(0, screen_width), random.randint(0, screen_height))
            pt2 = (random.randint(0, screen_width), random.randint(0, screen_height))
            color = random_color()
            thickness = random.randint(1, 3)
            cv2.line(canvas, pt1, pt2, color, thickness)
    
    elif shape_type == "gradient":
        for y in range(screen_height):
            color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
            cv2.line(canvas, (0, y), (screen_width, y), color, 1)
    
    elif shape_type == "wave":
        frequency = random.uniform(0.05, 0.2)
        amplitude = random.randint(20, 100)
        color = random_color()
        for x in range(0, screen_width, 5):
            y = int(screen_height / 2 + amplitude * np.sin(frequency * x))
            cv2.circle(canvas, (x, y), 5, color, -1)

def generate_visuals():
    global last_face_time
    canvas = np.zeros((screen_height, screen_width, 3), dtype=np.uint8)  # Black canvas

    # Fullscreen window
    cv2.namedWindow("Trippy AI Geometric Visuals", cv2.WND_PROP_FULLSCREEN)
    cv2.setWindowProperty("Trippy AI Geometric Visuals", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)

    while True:
        # Apply blur for smooth visuals
        canvas = cv2.GaussianBlur(canvas, (5, 5), 0)

        # Draw random shapes
        draw_random_shape(canvas)

        # Transparency effect
        overlay = canvas.copy()
        alpha = 0.2  # Transparency level
        cv2.addWeighted(overlay, alpha, canvas, 1 - alpha, 0, canvas)

        # Display visuals
        cv2.imshow("Trippy AI Geometric Visuals", canvas)

        # Exit on 'q' key press
        if cv2.waitKey(50) & 0xFF == ord('q'):
            break

    cv2.destroyAllWindows()

# Run the visualization
generate_visuals()
