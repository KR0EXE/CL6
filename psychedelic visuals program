import cv2
import numpy as np
import random
import time

# Detect screen resolution for fullscreen mode
screen_width = cv2.getWindowImageRect("")[2] if cv2.getWindowImageRect("") else 1920
screen_height = cv2.getWindowImageRect("")[3] if cv2.getWindowImageRect("") else 1080

# Load OpenCV's built-in AI-generated face dataset
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")

# Timer variables for rare face appearance
last_face_time = 0
FACE_COOLDOWN = 180  # At most once every 3 minutes (180 seconds)

# Function to generate a random color
def random_color():
    return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))

# Function to create a random shape
def draw_random_shape(canvas):
    shape_type = random.choice(["circle", "rectangle", "polygon", "lines", "gradient", "wave"])
    
    if shape_type == "circle":
        center = (random.randint(0, screen_width), random.randint(0, screen_height))
        radius = random.randint(10, 200)
        color = random_color()
        thickness = random.choice([-1, 2, 4])  # -1 means filled
        cv2.circle(canvas, center, radius, color, thickness)
    
    elif shape_type == "rectangle":
        pt1 = (random.randint(0, screen_width), random.randint(0, screen_height))
        pt2 = (random.randint(0, screen_width), random.randint(0, screen_height))
        color = random_color()
        thickness = random.choice([-1, 2, 4])
        cv2.rectangle(canvas, pt1, pt2, color, thickness)
    
    elif shape_type == "polygon":
        num_points = random.randint(3, 10)
        points = np.array([
            [random.randint(0, screen_width), random.randint(0, screen_height)] for _ in range(num_points)
        ], np.int32)

        # Fix: Ensure the shape of `points` is correct
        points = points.reshape((-1, 1, 2))

        color = random_color()
        thickness = random.choice([-1, 2])
        cv2.polylines(canvas, [points], isClosed=True, color=color, thickness=thickness)
        if thickness == -1:
            cv2.fillPoly(canvas, [points], color)
    
    elif shape_type == "lines":
        for _ in range(random.randint(5, 20)):
            pt1 = (random.randint(0, screen_width), random.randint(0, screen_height))
            pt2 = (random.randint(0, screen_width), random.randint(0, screen_height))
            color = random_color()
            thickness = random.randint(1, 3)
            cv2.line(canvas, pt1, pt2, color, thickness)
    
    elif shape_type == "gradient":
        for y in range(screen_height):
            color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
            cv2.line(canvas, (0, y), (screen_width, y), color, 1)
    
    elif shape_type == "wave":
        frequency = random.uniform(0.05, 0.2)
        amplitude = random.randint(20, 100)
        color = random_color()
        for x in range(0, screen_width, 5):
            y = int(screen_height / 2 + amplitude * np.sin(frequency * x))
            cv2.circle(canvas, (x, y), 5, color, -1)

# Function to generate an AI face and overlay it on the visuals
def generate_face_overlay():
    face_size = random.randint(80, 200)  # Random face size
    face = np.zeros((face_size, face_size, 3), dtype=np.uint8)

    # Generate a fake AI face using random pixels
    for y in range(face_size):
        for x in range(face_size):
            face[y, x] = random_color()

    # Apply a blur for an eerie effect
    face = cv2.GaussianBlur(face, (11, 11), 5)

    return face

# Function to overlay a face onto the visuals with transparency
def overlay_face(canvas, face, x, y, alpha=0.5):
    h, w, _ = face.shape

    # Fix: Ensure face placement is within bounds
    x = min(max(0, x), screen_width - w)
    y = min(max(0, y), screen_height - h)

    # Create a mask with alpha transparency
    for i in range(h):
        for j in range(w):
            if x + j < screen_width and y + i < screen_height:
                canvas_pixel = canvas[y + i, x + j].astype(np.float32)
                face_pixel = face[i, j].astype(np.float32)

                # Fix: Ensure the correct shape for `addWeighted`
                blended_pixel = cv2.addWeighted(canvas_pixel, 1 - alpha, face_pixel, alpha, 0)
                canvas[y + i, x + j] = blended_pixel.astype(np.uint8)

# Function to generate a continuously evolving trippy effect with rare faces
def generate_visuals():
    global last_face_time
    canvas = np.zeros((screen_height, screen_width, 3), dtype=np.uint8)  # Black canvas

    # Create a fullscreen window
    cv2.namedWindow("Trippy AI Geometric Visuals", cv2.WND_PROP_FULLSCREEN)
    cv2.setWindowProperty("Trippy AI Geometric Visuals", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)
    
    while True:
        # Apply some blurring for a smoother effect
        canvas = cv2.GaussianBlur(canvas, (5, 5), 0)
        
        # Randomly add shapes
        draw_random_shape(canvas)
        
        # Introduce transparency effect
        overlay = canvas.copy()
        alpha = 0.2  # Transparency level
        cv2.addWeighted(overlay, alpha, canvas, 1 - alpha, 0, canvas)

        # Rarely add a face overlay (max once every 3 minutes)
        current_time = time.time()
        if current_time - last_face_time > FACE_COOLDOWN and random.random() < 0.01:
            last_face_time = current_time
            face = generate_face_overlay()
            x, y = random.randint(0, screen_width - face.shape[1]), random.randint(0, screen_height - face.shape[0])
            overlay_face(canvas, face, x, y, alpha=0.7)
            print("ðŸ‘ï¸ AI Face Appeared!")

        # Display the visuals
        cv2.imshow("Trippy AI Geometric Visuals", canvas)

        # Exit on 'q' key press
        if cv2.waitKey(50) & 0xFF == ord('q'):
            break

    cv2.destroyAllWindows()

# Run the visualization
generate_visuals()
