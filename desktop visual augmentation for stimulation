import sys
import random
from PyQt5.QtWidgets import QApplication, QWidget, QDesktopWidget
from PyQt5.QtCore import Qt, QTimer, QPointF
from PyQt5.QtGui import QPainter, QColor, QIcon

# Windows-specific: import ctypes for native API calls.
if sys.platform.startswith("win"):
    import ctypes

class OverlayWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()
        self.initParticles()
        
    def initUI(self):
        self.setWindowTitle("Screen Augmentation Overlay")
        # Build initial window flags.
        flags = Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint
        # If available, add the flag to allow transparent input.
        if hasattr(Qt, "WindowTransparentForInput"):
            flags |= Qt.WindowTransparentForInput
        self.setWindowFlags(flags)
        
        # Set a custom icon.
        self.setWindowIcon(QIcon("unique_icon.png"))
        # Enable per-pixel transparency.
        self.setAttribute(Qt.WA_TranslucentBackground)
        # Instruct Qt to ignore mouse events.
        self.setAttribute(Qt.WA_TransparentForMouseEvents)
        # Optionally disable system background painting.
        self.setAttribute(Qt.WA_NoSystemBackground, True)
        # Ensure the window never accepts focus.
        self.setFocusPolicy(Qt.NoFocus)
        
        # Resize the window to cover the entire screen.
        self.setGeometry(QDesktopWidget().screenGeometry())
        
        # Show the window first (so we have a valid window handle).
        self.show()
        
        # Delay the Windows API call so the window is fully created.
        if sys.platform.startswith("win"):
            QTimer.singleShot(100, self.make_click_through)
        
        # Set up a timer to update the particle animation.
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.updateParticles)
        self.timer.start(30)  # ~33 frames per second.
    
    def make_click_through(self):
        """
        Applies Windows-specific extended window styles to force the window
        to be click-through.
        """
        if sys.platform.startswith("win"):
            # Get the native window handle.
            hwnd = int(self.winId())
            GWL_EXSTYLE    = -20
            WS_EX_LAYERED    = 0x00080000
            WS_EX_TRANSPARENT = 0x00000020
            WS_EX_NOACTIVATE = 0x08000000

            try:
                # For 64-bit Windows.
                get_ex_style = ctypes.windll.user32.GetWindowLongPtrW
                set_ex_style = ctypes.windll.user32.SetWindowLongPtrW
            except AttributeError:
                # Fallback for 32-bit Windows.
                get_ex_style = ctypes.windll.user32.GetWindowLongW
                set_ex_style = ctypes.windll.user32.SetWindowLongW

            # Get current extended style.
            style = get_ex_style(hwnd, GWL_EXSTYLE)
            # Add the layered, transparent, and no-activate flags.
            new_style = style | WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_NOACTIVATE
            set_ex_style(hwnd, GWL_EXSTYLE, new_style)
            # Optionally, call SetLayeredWindowAttributes.
            LWA_ALPHA = 0x2
            # 255 means fully opaque (alpha is used here to trigger the layered behavior).
            ctypes.windll.user32.SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA)
    
    def initParticles(self):
        # Initialize a list of particles with random attributes.
        self.particles = []
        for _ in range(100):
            x = random.uniform(0, self.width())
            y = random.uniform(0, self.height())
            dx = random.uniform(-2, 2)
            dy = random.uniform(-2, 2)
            radius = random.uniform(5, 15)
            color = QColor(
                random.randint(0, 255),
                random.randint(0, 255),
                random.randint(0, 255),
                random.randint(100, 200)  # Semi-transparent.
            )
            particle = {
                'pos': QPointF(x, y),
                'vel': QPointF(dx, dy),
                'radius': radius,
                'color': color
            }
            self.particles.append(particle)
    
    def updateParticles(self):
        # Update each particle's position and bounce them off the screen edges.
        for particle in self.particles:
            pos = particle['pos']
            vel = particle['vel']
            new_x = pos.x() + vel.x()
            new_y = pos.y() + vel.y()
            
            if new_x < 0 or new_x > self.width():
                vel.setX(-vel.x())
            if new_y < 0 or new_y > self.height():
                vel.setY(-vel.y())
            
            particle['pos'] = QPointF(pos.x() + vel.x(), pos.y() + vel.y())
        
        self.update()  # Trigger repaint.
    
    def paintEvent(self, event):
        # Draw the overlay and particles.
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Draw a semi-transparent black rectangle for a trailing/fading effect.
        painter.fillRect(self.rect(), QColor(0, 0, 0, 10))
        
        # Draw each particle.
        for particle in self.particles:
            painter.setBrush(particle['color'])
            painter.setPen(Qt.NoPen)
            pos = particle['pos']
            radius = particle['radius']
            painter.drawEllipse(pos, radius, radius)

def main():
    app = QApplication(sys.argv)
    # Set the application icon (for the taskbar).
    app.setWindowIcon(QIcon("unique_icon.png"))
    overlay = OverlayWindow()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
